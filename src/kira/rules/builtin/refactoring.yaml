name: Refactoring Best Practices
category: refactoring
description: |
  Guidelines for safely improving code structure without changing behavior.
  Focus on incremental changes, preserving functionality, and reducing complexity.

triggers:
  - refactor
  - clean up
  - improve
  - simplify
  - restructure
  - reorganize
  - extract
  - rename
  - move
  - split
  - consolidate
  - optimize

principles:
  - Refactoring changes structure, not behavior
  - Make changes in small, verifiable steps
  - Always have tests before refactoring (or add them first)
  - Leave the code better than you found it
  - When in doubt, don't refactor - understand first
  - Refactor to make the next change easier

rules:
  # Safety First
  - text: Ensure tests exist and pass before starting any refactoring
    priority: 10
  - text: Make one type of change at a time - don't mix refactoring with feature work
    priority: 10
  - text: Commit frequently - each small step should be a potential stopping point
    priority: 9
  - text: If tests don't exist, write characterization tests first to capture current behavior
    priority: 9

  # Code Smells to Address
  - text: Extract methods when you see comments explaining what a block does
    priority: 8
  - text: Replace magic numbers/strings with named constants
    priority: 8
  - text: Eliminate duplicate code by extracting common functionality
    priority: 8
  - text: Break up long methods (>20 lines is a smell, >50 needs attention)
    priority: 7
  - text: Reduce parameter lists - more than 3-4 suggests a missing object
    priority: 7

  # Naming & Clarity
  - text: Rename unclear variables/functions to reveal intent
    priority: 9
  - text: Replace boolean parameters with enum or separate methods
    priority: 7
  - text: Use domain language - code should read like the business speaks
    priority: 8

  # Structure Improvements
  - text: Move methods to the class where their data lives
    priority: 7
  - text: Extract class when a class has multiple responsibilities
    priority: 8
  - text: Introduce parameter object for frequently-passed parameter groups
    priority: 6
  - text: Replace conditionals with polymorphism when switching on type
    priority: 7
  - text: Encapsulate collection - don't expose raw lists/dicts
    priority: 6

  # Dependency Management
  - text: Inject dependencies instead of creating them internally
    priority: 8
  - text: Replace inheritance with composition where behavior varies
    priority: 7
  - text: Hide implementation details behind interfaces
    priority: 7
  - text: Break circular dependencies by extracting shared concepts
    priority: 8

  # Simplification
  - text: Remove dead code - version control remembers it
    priority: 9
  - text: Collapse unnecessary indirection (wrapper methods that just delegate)
    priority: 7
  - text: Simplify conditional expressions - extract complex conditions to methods
    priority: 7
  - text: Replace nested conditionals with guard clauses
    priority: 8

  # Preservation
  - text: Preserve all existing public interfaces during internal refactoring
    priority: 10
  - text: Deprecate before removing - give consumers time to migrate
    priority: 8
  - text: Document breaking changes clearly if unavoidable
    priority: 9

anti_patterns:
  - Big bang refactoring - changing everything at once
  - Refactoring without tests as a safety net
  - Mixing refactoring with feature development in same commit
  - Refactoring code you don't understand yet
  - Gold plating - over-engineering during refactoring
  - Changing behavior while claiming to "just refactor"
  - Removing "unused" code without verifying it's truly unused
  - Breaking public APIs without migration path
  - Refactoring for the sake of it - no clear improvement goal

examples:
  good: |
    # Before: Long method with comment
    # After: Extracted method with descriptive name

    def process_order(order: Order) -> Receipt:
        validated_order = self._validate_order(order)
        priced_order = self._apply_pricing(validated_order)
        return self._generate_receipt(priced_order)

  bad: |
    # "Refactoring" that changes behavior
    def process_order(order):
        # I'll just add this validation while I'm here...
        if order.total > 10000:
            raise Exception("Order too large")  # NEW BEHAVIOR!
        # ... rest of refactoring
