name: Modern Coding Practices
category: coding
description: |
  Best practices for writing clean, maintainable, and robust code.
  These rules apply to general software development across languages.

triggers:
  - implement
  - code
  - function
  - class
  - method
  - write
  - create
  - add
  - build
  - develop

principles:
  - Write code for humans first, computers second
  - Make the code self-documenting through clear naming
  - Prefer simplicity over cleverness
  - Fail fast and fail loudly
  - Composition over inheritance
  - Program to interfaces, not implementations

rules:
  # Naming & Readability
  - text: Use descriptive, intention-revealing names for variables, functions, and classes
    priority: 10
  - text: Follow consistent naming conventions (camelCase, snake_case) per language standards
    priority: 9
  - text: Avoid abbreviations unless universally understood (e.g., id, url, http)
    priority: 7

  # Functions & Methods
  - text: Keep functions small and focused - do one thing well (Single Responsibility)
    priority: 10
  - text: Limit function parameters to 3-4 maximum; use objects for more
    priority: 8
  - text: Return early to avoid deep nesting - guard clauses first
    priority: 9
  - text: Pure functions are preferred - minimize side effects
    priority: 8
  - text: Avoid boolean parameters - they obscure intent at call sites
    priority: 7

  # Error Handling
  - text: Handle errors explicitly - never swallow exceptions silently
    priority: 10
  - text: Use specific exception types, not generic catches
    priority: 8
  - text: Validate inputs at system boundaries (API, user input, external data)
    priority: 9
  - text: Fail fast with clear error messages that help debugging
    priority: 8

  # Data & State
  - text: Prefer immutable data structures when possible
    priority: 8
  - text: No magic numbers or strings - use named constants
    priority: 9
  - text: Minimize mutable shared state - it's the root of many bugs
    priority: 9
  - text: Initialize variables close to their usage
    priority: 6

  # Code Organization
  - text: Keep files focused - one primary class/module per file
    priority: 7
  - text: Group related code together; separate unrelated code
    priority: 7
  - text: Dependencies should flow inward (Clean Architecture)
    priority: 8
  - text: Avoid circular dependencies between modules
    priority: 9

  # Types & Safety
  - text: Use type hints/annotations for function signatures
    priority: 8
  - text: Leverage the type system to make invalid states unrepresentable
    priority: 8
  - text: Prefer Option/Maybe types over null/None where available
    priority: 7

  # Testing Mindset
  - text: Write code that is easy to test - if it's hard to test, refactor
    priority: 8
  - text: Inject dependencies rather than creating them internally
    priority: 8
  - text: Separate business logic from I/O and side effects
    priority: 9

anti_patterns:
  - God classes/functions that do everything
  - Deep nesting (more than 3 levels)
  - Hardcoded values scattered throughout code
  - Copy-paste programming instead of abstraction
  - Premature optimization before measuring
  - Comments explaining what instead of why
  - Catching and ignoring all exceptions
  - Global mutable state
  - Tight coupling between unrelated modules
  - Boolean blindness (passing true/false without context)

examples:
  good: |
    def calculate_discount(price: Decimal, customer: Customer) -> Decimal:
        if not customer.is_active:
            return Decimal("0")

        discount_rate = LOYALTY_DISCOUNTS.get(customer.tier, Decimal("0"))
        return price * discount_rate

  bad: |
    def calc(p, c):
        # calculate discount
        if c.a == True:
            if c.t == 1:
                return p * 0.1
            elif c.t == 2:
                return p * 0.2
        return 0
